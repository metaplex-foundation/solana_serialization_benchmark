// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_EXAMPLE_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_EXAMPLE_ENUM: i8 = 9;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_EXAMPLE_ENUM: [ExampleEnum; 10] = [
  ExampleEnum::Zero,
  ExampleEnum::One,
  ExampleEnum::Two,
  ExampleEnum::Three,
  ExampleEnum::Four,
  ExampleEnum::Five,
  ExampleEnum::Six,
  ExampleEnum::Seven,
  ExampleEnum::Eight,
  ExampleEnum::Nine,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ExampleEnum(pub i8);
#[allow(non_upper_case_globals)]
impl ExampleEnum {
  pub const Zero: Self = Self(0);
  pub const One: Self = Self(1);
  pub const Two: Self = Self(2);
  pub const Three: Self = Self(3);
  pub const Four: Self = Self(4);
  pub const Five: Self = Self(5);
  pub const Six: Self = Self(6);
  pub const Seven: Self = Self(7);
  pub const Eight: Self = Self(8);
  pub const Nine: Self = Self(9);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 9;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Zero,
    Self::One,
    Self::Two,
    Self::Three,
    Self::Four,
    Self::Five,
    Self::Six,
    Self::Seven,
    Self::Eight,
    Self::Nine,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Zero => Some("Zero"),
      Self::One => Some("One"),
      Self::Two => Some("Two"),
      Self::Three => Some("Three"),
      Self::Four => Some("Four"),
      Self::Five => Some("Five"),
      Self::Six => Some("Six"),
      Self::Seven => Some("Seven"),
      Self::Eight => Some("Eight"),
      Self::Nine => Some("Nine"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ExampleEnum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ExampleEnum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ExampleEnum {
    type Output = ExampleEnum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ExampleEnum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ExampleEnum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ExampleEnum {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_EXAMPLE_VARIANT: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_EXAMPLE_VARIANT: u8 = 5;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_EXAMPLE_VARIANT: [ExampleVariant; 6] = [
  ExampleVariant::NONE,
  ExampleVariant::Zero,
  ExampleVariant::One,
  ExampleVariant::Two,
  ExampleVariant::Three,
  ExampleVariant::Four,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ExampleVariant(pub u8);
#[allow(non_upper_case_globals)]
impl ExampleVariant {
  pub const NONE: Self = Self(0);
  pub const Zero: Self = Self(1);
  pub const One: Self = Self(2);
  pub const Two: Self = Self(3);
  pub const Three: Self = Self(4);
  pub const Four: Self = Self(5);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 5;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::Zero,
    Self::One,
    Self::Two,
    Self::Three,
    Self::Four,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::Zero => Some("Zero"),
      Self::One => Some("One"),
      Self::Two => Some("Two"),
      Self::Three => Some("Three"),
      Self::Four => Some("Four"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ExampleVariant {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ExampleVariant {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ExampleVariant {
    type Output = ExampleVariant;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ExampleVariant {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ExampleVariant {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ExampleVariant {}
pub struct ExampleVariantUnionTableOffset {}

#[allow(clippy::upper_case_acronyms)]
#[derive(Debug, Clone, PartialEq)]
pub enum ExampleVariantT {
  NONE,
  Zero(Box<ZeroST>),
  One(Box<OneST>),
  Two(Box<TwoST>),
  Three(Box<ThreeST>),
  Four(Box<PublicKeyHolderT>),
}
impl Default for ExampleVariantT {
  fn default() -> Self {
    Self::NONE
  }
}
impl ExampleVariantT {
  pub fn example_variant_type(&self) -> ExampleVariant {
    match self {
      Self::NONE => ExampleVariant::NONE,
      Self::Zero(_) => ExampleVariant::Zero,
      Self::One(_) => ExampleVariant::One,
      Self::Two(_) => ExampleVariant::Two,
      Self::Three(_) => ExampleVariant::Three,
      Self::Four(_) => ExampleVariant::Four,
    }
  }
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(&self, fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>) -> Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>> {
    match self {
      Self::NONE => None,
      Self::Zero(v) => Some(v.pack(fbb).as_union_value()),
      Self::One(v) => Some(v.pack(fbb).as_union_value()),
      Self::Two(v) => Some(v.pack(fbb).as_union_value()),
      Self::Three(v) => Some(v.pack(fbb).as_union_value()),
      Self::Four(v) => Some(v.pack(fbb).as_union_value()),
    }
  }
  /// If the union variant matches, return the owned ZeroST, setting the union to NONE.
  pub fn take_zero(&mut self) -> Option<Box<ZeroST>> {
    if let Self::Zero(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::Zero(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the ZeroST.
  pub fn as_zero(&self) -> Option<&ZeroST> {
    if let Self::Zero(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the ZeroST.
  pub fn as_zero_mut(&mut self) -> Option<&mut ZeroST> {
    if let Self::Zero(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned OneST, setting the union to NONE.
  pub fn take_one(&mut self) -> Option<Box<OneST>> {
    if let Self::One(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::One(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the OneST.
  pub fn as_one(&self) -> Option<&OneST> {
    if let Self::One(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the OneST.
  pub fn as_one_mut(&mut self) -> Option<&mut OneST> {
    if let Self::One(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned TwoST, setting the union to NONE.
  pub fn take_two(&mut self) -> Option<Box<TwoST>> {
    if let Self::Two(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::Two(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the TwoST.
  pub fn as_two(&self) -> Option<&TwoST> {
    if let Self::Two(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the TwoST.
  pub fn as_two_mut(&mut self) -> Option<&mut TwoST> {
    if let Self::Two(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned ThreeST, setting the union to NONE.
  pub fn take_three(&mut self) -> Option<Box<ThreeST>> {
    if let Self::Three(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::Three(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the ThreeST.
  pub fn as_three(&self) -> Option<&ThreeST> {
    if let Self::Three(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the ThreeST.
  pub fn as_three_mut(&mut self) -> Option<&mut ThreeST> {
    if let Self::Three(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned PublicKeyHolderT, setting the union to NONE.
  pub fn take_four(&mut self) -> Option<Box<PublicKeyHolderT>> {
    if let Self::Four(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::Four(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the PublicKeyHolderT.
  pub fn as_four(&self) -> Option<&PublicKeyHolderT> {
    if let Self::Four(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the PublicKeyHolderT.
  pub fn as_four_mut(&mut self) -> Option<&mut PublicKeyHolderT> {
    if let Self::Four(v) = self { Some(v.as_mut()) } else { None }
  }
}
// struct PublicKey, aligned to 1
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct PublicKey(pub [u8; 32]);
impl Default for PublicKey { 
  fn default() -> Self { 
    Self([0; 32])
  }
}
impl core::fmt::Debug for PublicKey {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("PublicKey")
      .field("b", &self.b())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for PublicKey {}
impl<'a> flatbuffers::Follow<'a> for PublicKey {
  type Inner = &'a PublicKey;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a PublicKey>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a PublicKey {
  type Inner = &'a PublicKey;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<PublicKey>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for PublicKey {
    type Output = PublicKey;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const PublicKey as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for PublicKey {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> PublicKey {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    b: &[u8; 32],
  ) -> Self {
    let mut s = Self([0; 32]);
    s.set_b(b);
    s
  }

  pub fn b(&'a self) -> flatbuffers::Array<'a, u8, 32> {
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid array in this slot
    unsafe { flatbuffers::Array::follow(&self.0, 0) }
  }

  pub fn set_b(&mut self, items: &[u8; 32]) {
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid array in this slot
    unsafe { flatbuffers::emplace_scalar_array(&mut self.0, 0, items) };
  }

  pub fn unpack(&self) -> PublicKeyT {
    PublicKeyT {
      b: self.b().into(),
    }
  }
}

#[derive(Debug, Clone, PartialEq, Default)]
pub struct PublicKeyT {
  pub b: [u8; 32],
}
impl PublicKeyT {
  pub fn pack(&self) -> PublicKey {
    PublicKey::new(
      &self.b,
    )
  }
}

pub enum PublicKeyHolderOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PublicKeyHolder<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PublicKeyHolder<'a> {
  type Inner = PublicKeyHolder<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PublicKeyHolder<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PublicKeyHolder { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PublicKeyHolderArgs<'args>
  ) -> flatbuffers::WIPOffset<PublicKeyHolder<'bldr>> {
    let mut builder = PublicKeyHolderBuilder::new(_fbb);
    if let Some(x) = args.key { builder.add_key(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> PublicKeyHolderT {
    let key = self.key().map(|x| {
      x.unpack()
    });
    PublicKeyHolderT {
      key,
    }
  }

  #[inline]
  pub fn key(&self) -> Option<&'a PublicKey> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<PublicKey>(PublicKeyHolder::VT_KEY, None)}
  }
}

impl flatbuffers::Verifiable for PublicKeyHolder<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<PublicKey>("key", Self::VT_KEY, false)?
     .finish();
    Ok(())
  }
}
pub struct PublicKeyHolderArgs<'a> {
    pub key: Option<&'a PublicKey>,
}
impl<'a> Default for PublicKeyHolderArgs<'a> {
  #[inline]
  fn default() -> Self {
    PublicKeyHolderArgs {
      key: None,
    }
  }
}

pub struct PublicKeyHolderBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PublicKeyHolderBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key(&mut self, key: &PublicKey) {
    self.fbb_.push_slot_always::<&PublicKey>(PublicKeyHolder::VT_KEY, key);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PublicKeyHolderBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PublicKeyHolderBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PublicKeyHolder<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PublicKeyHolder<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PublicKeyHolder");
      ds.field("key", &self.key());
      ds.finish()
  }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PublicKeyHolderT {
  pub key: Option<PublicKeyT>,
}
impl Default for PublicKeyHolderT {
  fn default() -> Self {
    Self {
      key: None,
    }
  }
}
impl PublicKeyHolderT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<PublicKeyHolder<'b>> {
    let key_tmp = self.key.as_ref().map(|x| x.pack());
    let key = key_tmp.as_ref();
    PublicKeyHolder::create(_fbb, &PublicKeyHolderArgs{
      key,
    })
  }
}
pub enum ZeroSOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ZeroS<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ZeroS<'a> {
  type Inner = ZeroS<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ZeroS<'a> {
  pub const VT_ZERO: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ZeroS { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ZeroSArgs
  ) -> flatbuffers::WIPOffset<ZeroS<'bldr>> {
    let mut builder = ZeroSBuilder::new(_fbb);
    builder.add_zero(args.zero);
    builder.finish()
  }

  pub fn unpack(&self) -> ZeroST {
    let zero = self.zero();
    ZeroST {
      zero,
    }
  }

  #[inline]
  pub fn zero(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(ZeroS::VT_ZERO, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ZeroS<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("zero", Self::VT_ZERO, false)?
     .finish();
    Ok(())
  }
}
pub struct ZeroSArgs {
    pub zero: u8,
}
impl<'a> Default for ZeroSArgs {
  #[inline]
  fn default() -> Self {
    ZeroSArgs {
      zero: 0,
    }
  }
}

pub struct ZeroSBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ZeroSBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_zero(&mut self, zero: u8) {
    self.fbb_.push_slot::<u8>(ZeroS::VT_ZERO, zero, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ZeroSBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ZeroSBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ZeroS<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ZeroS<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ZeroS");
      ds.field("zero", &self.zero());
      ds.finish()
  }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ZeroST {
  pub zero: u8,
}
impl Default for ZeroST {
  fn default() -> Self {
    Self {
      zero: 0,
    }
  }
}
impl ZeroST {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ZeroS<'b>> {
    let zero = self.zero;
    ZeroS::create(_fbb, &ZeroSArgs{
      zero,
    })
  }
}
pub enum OneSOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct OneS<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for OneS<'a> {
  type Inner = OneS<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> OneS<'a> {
  pub const VT_ONE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    OneS { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args OneSArgs
  ) -> flatbuffers::WIPOffset<OneS<'bldr>> {
    let mut builder = OneSBuilder::new(_fbb);
    builder.add_one(args.one);
    builder.finish()
  }

  pub fn unpack(&self) -> OneST {
    let one = self.one();
    OneST {
      one,
    }
  }

  #[inline]
  pub fn one(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(OneS::VT_ONE, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for OneS<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>("one", Self::VT_ONE, false)?
     .finish();
    Ok(())
  }
}
pub struct OneSArgs {
    pub one: u16,
}
impl<'a> Default for OneSArgs {
  #[inline]
  fn default() -> Self {
    OneSArgs {
      one: 0,
    }
  }
}

pub struct OneSBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> OneSBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_one(&mut self, one: u16) {
    self.fbb_.push_slot::<u16>(OneS::VT_ONE, one, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> OneSBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    OneSBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<OneS<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for OneS<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("OneS");
      ds.field("one", &self.one());
      ds.finish()
  }
}
#[derive(Debug, Clone, PartialEq)]
pub struct OneST {
  pub one: u16,
}
impl Default for OneST {
  fn default() -> Self {
    Self {
      one: 0,
    }
  }
}
impl OneST {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<OneS<'b>> {
    let one = self.one;
    OneS::create(_fbb, &OneSArgs{
      one,
    })
  }
}
pub enum TwoSOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TwoS<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TwoS<'a> {
  type Inner = TwoS<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TwoS<'a> {
  pub const VT_TWO: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TwoS { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TwoSArgs
  ) -> flatbuffers::WIPOffset<TwoS<'bldr>> {
    let mut builder = TwoSBuilder::new(_fbb);
    builder.add_two(args.two);
    builder.finish()
  }

  pub fn unpack(&self) -> TwoST {
    let two = self.two();
    TwoST {
      two,
    }
  }

  #[inline]
  pub fn two(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(TwoS::VT_TWO, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for TwoS<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("two", Self::VT_TWO, false)?
     .finish();
    Ok(())
  }
}
pub struct TwoSArgs {
    pub two: u32,
}
impl<'a> Default for TwoSArgs {
  #[inline]
  fn default() -> Self {
    TwoSArgs {
      two: 0,
    }
  }
}

pub struct TwoSBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TwoSBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_two(&mut self, two: u32) {
    self.fbb_.push_slot::<u32>(TwoS::VT_TWO, two, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TwoSBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TwoSBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TwoS<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TwoS<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TwoS");
      ds.field("two", &self.two());
      ds.finish()
  }
}
#[derive(Debug, Clone, PartialEq)]
pub struct TwoST {
  pub two: u32,
}
impl Default for TwoST {
  fn default() -> Self {
    Self {
      two: 0,
    }
  }
}
impl TwoST {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<TwoS<'b>> {
    let two = self.two;
    TwoS::create(_fbb, &TwoSArgs{
      two,
    })
  }
}
pub enum ThreeSOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ThreeS<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ThreeS<'a> {
  type Inner = ThreeS<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ThreeS<'a> {
  pub const VT_THREE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ThreeS { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ThreeSArgs
  ) -> flatbuffers::WIPOffset<ThreeS<'bldr>> {
    let mut builder = ThreeSBuilder::new(_fbb);
    builder.add_three(args.three);
    builder.finish()
  }

  pub fn unpack(&self) -> ThreeST {
    let three = self.three();
    ThreeST {
      three,
    }
  }

  #[inline]
  pub fn three(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(ThreeS::VT_THREE, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ThreeS<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("three", Self::VT_THREE, false)?
     .finish();
    Ok(())
  }
}
pub struct ThreeSArgs {
    pub three: u64,
}
impl<'a> Default for ThreeSArgs {
  #[inline]
  fn default() -> Self {
    ThreeSArgs {
      three: 0,
    }
  }
}

pub struct ThreeSBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ThreeSBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_three(&mut self, three: u64) {
    self.fbb_.push_slot::<u64>(ThreeS::VT_THREE, three, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ThreeSBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ThreeSBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ThreeS<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ThreeS<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ThreeS");
      ds.field("three", &self.three());
      ds.finish()
  }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ThreeST {
  pub three: u64,
}
impl Default for ThreeST {
  fn default() -> Self {
    Self {
      three: 0,
    }
  }
}
impl ThreeST {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ThreeS<'b>> {
    let three = self.three;
    ThreeS::create(_fbb, &ThreeSArgs{
      three,
    })
  }
}
pub enum ExampleStructOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ExampleStruct<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ExampleStruct<'a> {
  type Inner = ExampleStruct<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ExampleStruct<'a> {
  pub const VT_UNSIGNED8: flatbuffers::VOffsetT = 4;
  pub const VT_UNSIGNED16: flatbuffers::VOffsetT = 6;
  pub const VT_UNSIGNED32: flatbuffers::VOffsetT = 8;
  pub const VT_UNSIGNED64: flatbuffers::VOffsetT = 10;
  pub const VT_PUBLIC_KEY: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ExampleStruct { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ExampleStructArgs<'args>
  ) -> flatbuffers::WIPOffset<ExampleStruct<'bldr>> {
    let mut builder = ExampleStructBuilder::new(_fbb);
    builder.add_unsigned64(args.unsigned64);
    if let Some(x) = args.public_key { builder.add_public_key(x); }
    builder.add_unsigned32(args.unsigned32);
    builder.add_unsigned16(args.unsigned16);
    builder.add_unsigned8(args.unsigned8);
    builder.finish()
  }

  pub fn unpack(&self) -> ExampleStructT {
    let unsigned8 = self.unsigned8();
    let unsigned16 = self.unsigned16();
    let unsigned32 = self.unsigned32();
    let unsigned64 = self.unsigned64();
    let public_key = self.public_key().map(|x| {
      x.unpack()
    });
    ExampleStructT {
      unsigned8,
      unsigned16,
      unsigned32,
      unsigned64,
      public_key,
    }
  }

  #[inline]
  pub fn unsigned8(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(ExampleStruct::VT_UNSIGNED8, Some(0)).unwrap()}
  }
  #[inline]
  pub fn unsigned16(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(ExampleStruct::VT_UNSIGNED16, Some(0)).unwrap()}
  }
  #[inline]
  pub fn unsigned32(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(ExampleStruct::VT_UNSIGNED32, Some(0)).unwrap()}
  }
  #[inline]
  pub fn unsigned64(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(ExampleStruct::VT_UNSIGNED64, Some(0)).unwrap()}
  }
  #[inline]
  pub fn public_key(&self) -> Option<&'a PublicKey> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<PublicKey>(ExampleStruct::VT_PUBLIC_KEY, None)}
  }
}

impl flatbuffers::Verifiable for ExampleStruct<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("unsigned8", Self::VT_UNSIGNED8, false)?
     .visit_field::<u16>("unsigned16", Self::VT_UNSIGNED16, false)?
     .visit_field::<u32>("unsigned32", Self::VT_UNSIGNED32, false)?
     .visit_field::<u64>("unsigned64", Self::VT_UNSIGNED64, false)?
     .visit_field::<PublicKey>("public_key", Self::VT_PUBLIC_KEY, false)?
     .finish();
    Ok(())
  }
}
pub struct ExampleStructArgs<'a> {
    pub unsigned8: u8,
    pub unsigned16: u16,
    pub unsigned32: u32,
    pub unsigned64: u64,
    pub public_key: Option<&'a PublicKey>,
}
impl<'a> Default for ExampleStructArgs<'a> {
  #[inline]
  fn default() -> Self {
    ExampleStructArgs {
      unsigned8: 0,
      unsigned16: 0,
      unsigned32: 0,
      unsigned64: 0,
      public_key: None,
    }
  }
}

pub struct ExampleStructBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ExampleStructBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_unsigned8(&mut self, unsigned8: u8) {
    self.fbb_.push_slot::<u8>(ExampleStruct::VT_UNSIGNED8, unsigned8, 0);
  }
  #[inline]
  pub fn add_unsigned16(&mut self, unsigned16: u16) {
    self.fbb_.push_slot::<u16>(ExampleStruct::VT_UNSIGNED16, unsigned16, 0);
  }
  #[inline]
  pub fn add_unsigned32(&mut self, unsigned32: u32) {
    self.fbb_.push_slot::<u32>(ExampleStruct::VT_UNSIGNED32, unsigned32, 0);
  }
  #[inline]
  pub fn add_unsigned64(&mut self, unsigned64: u64) {
    self.fbb_.push_slot::<u64>(ExampleStruct::VT_UNSIGNED64, unsigned64, 0);
  }
  #[inline]
  pub fn add_public_key(&mut self, public_key: &PublicKey) {
    self.fbb_.push_slot_always::<&PublicKey>(ExampleStruct::VT_PUBLIC_KEY, public_key);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ExampleStructBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ExampleStructBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ExampleStruct<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ExampleStruct<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ExampleStruct");
      ds.field("unsigned8", &self.unsigned8());
      ds.field("unsigned16", &self.unsigned16());
      ds.field("unsigned32", &self.unsigned32());
      ds.field("unsigned64", &self.unsigned64());
      ds.field("public_key", &self.public_key());
      ds.finish()
  }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ExampleStructT {
  pub unsigned8: u8,
  pub unsigned16: u16,
  pub unsigned32: u32,
  pub unsigned64: u64,
  pub public_key: Option<PublicKeyT>,
}
impl Default for ExampleStructT {
  fn default() -> Self {
    Self {
      unsigned8: 0,
      unsigned16: 0,
      unsigned32: 0,
      unsigned64: 0,
      public_key: None,
    }
  }
}
impl ExampleStructT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ExampleStruct<'b>> {
    let unsigned8 = self.unsigned8;
    let unsigned16 = self.unsigned16;
    let unsigned32 = self.unsigned32;
    let unsigned64 = self.unsigned64;
    let public_key_tmp = self.public_key.as_ref().map(|x| x.pack());
    let public_key = public_key_tmp.as_ref();
    ExampleStruct::create(_fbb, &ExampleStructArgs{
      unsigned8,
      unsigned16,
      unsigned32,
      unsigned64,
      public_key,
    })
  }
}
pub enum PublicKeyMapEntryCollectionOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PublicKeyMapEntryCollection<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PublicKeyMapEntryCollection<'a> {
  type Inner = PublicKeyMapEntryCollection<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PublicKeyMapEntryCollection<'a> {
  pub const VT_MAP: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PublicKeyMapEntryCollection { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PublicKeyMapEntryCollectionArgs<'args>
  ) -> flatbuffers::WIPOffset<PublicKeyMapEntryCollection<'bldr>> {
    let mut builder = PublicKeyMapEntryCollectionBuilder::new(_fbb);
    if let Some(x) = args.map { builder.add_map(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> PublicKeyMapEntryCollectionT {
    let map = self.map().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    PublicKeyMapEntryCollectionT {
      map,
    }
  }

  #[inline]
  pub fn map(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PublicKeyMapEntry<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PublicKeyMapEntry>>>>(PublicKeyMapEntryCollection::VT_MAP, None)}
  }
}

impl flatbuffers::Verifiable for PublicKeyMapEntryCollection<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<PublicKeyMapEntry>>>>("map", Self::VT_MAP, false)?
     .finish();
    Ok(())
  }
}
pub struct PublicKeyMapEntryCollectionArgs<'a> {
    pub map: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PublicKeyMapEntry<'a>>>>>,
}
impl<'a> Default for PublicKeyMapEntryCollectionArgs<'a> {
  #[inline]
  fn default() -> Self {
    PublicKeyMapEntryCollectionArgs {
      map: None,
    }
  }
}

pub struct PublicKeyMapEntryCollectionBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PublicKeyMapEntryCollectionBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_map(&mut self, map: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<PublicKeyMapEntry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PublicKeyMapEntryCollection::VT_MAP, map);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PublicKeyMapEntryCollectionBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PublicKeyMapEntryCollectionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PublicKeyMapEntryCollection<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PublicKeyMapEntryCollection<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PublicKeyMapEntryCollection");
      ds.field("map", &self.map());
      ds.finish()
  }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PublicKeyMapEntryCollectionT {
  pub map: Option<Vec<PublicKeyMapEntryT>>,
}
impl Default for PublicKeyMapEntryCollectionT {
  fn default() -> Self {
    Self {
      map: None,
    }
  }
}
impl PublicKeyMapEntryCollectionT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<PublicKeyMapEntryCollection<'b>> {
    let map = self.map.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    PublicKeyMapEntryCollection::create(_fbb, &PublicKeyMapEntryCollectionArgs{
      map,
    })
  }
}
pub enum PublicKeyMapEntryOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PublicKeyMapEntry<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PublicKeyMapEntry<'a> {
  type Inner = PublicKeyMapEntry<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PublicKeyMapEntry<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PublicKeyMapEntry { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PublicKeyMapEntryArgs<'args>
  ) -> flatbuffers::WIPOffset<PublicKeyMapEntry<'bldr>> {
    let mut builder = PublicKeyMapEntryBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    if let Some(x) = args.key { builder.add_key(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> PublicKeyMapEntryT {
    let key = self.key().map(|x| {
      x.unpack()
    });
    let value = self.value().map(|x| {
      x.unpack()
    });
    PublicKeyMapEntryT {
      key,
      value,
    }
  }

  #[inline]
  pub fn key(&self) -> Option<&'a PublicKey> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<PublicKey>(PublicKeyMapEntry::VT_KEY, None)}
  }
  #[inline]
  pub fn value(&self) -> Option<&'a PublicKey> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<PublicKey>(PublicKeyMapEntry::VT_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for PublicKeyMapEntry<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<PublicKey>("key", Self::VT_KEY, false)?
     .visit_field::<PublicKey>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct PublicKeyMapEntryArgs<'a> {
    pub key: Option<&'a PublicKey>,
    pub value: Option<&'a PublicKey>,
}
impl<'a> Default for PublicKeyMapEntryArgs<'a> {
  #[inline]
  fn default() -> Self {
    PublicKeyMapEntryArgs {
      key: None,
      value: None,
    }
  }
}

pub struct PublicKeyMapEntryBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PublicKeyMapEntryBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key(&mut self, key: &PublicKey) {
    self.fbb_.push_slot_always::<&PublicKey>(PublicKeyMapEntry::VT_KEY, key);
  }
  #[inline]
  pub fn add_value(&mut self, value: &PublicKey) {
    self.fbb_.push_slot_always::<&PublicKey>(PublicKeyMapEntry::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PublicKeyMapEntryBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PublicKeyMapEntryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PublicKeyMapEntry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PublicKeyMapEntry<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PublicKeyMapEntry");
      ds.field("key", &self.key());
      ds.field("value", &self.value());
      ds.finish()
  }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PublicKeyMapEntryT {
  pub key: Option<PublicKeyT>,
  pub value: Option<PublicKeyT>,
}
impl Default for PublicKeyMapEntryT {
  fn default() -> Self {
    Self {
      key: None,
      value: None,
    }
  }
}
impl PublicKeyMapEntryT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<PublicKeyMapEntry<'b>> {
    let key_tmp = self.key.as_ref().map(|x| x.pack());
    let key = key_tmp.as_ref();
    let value_tmp = self.value.as_ref().map(|x| x.pack());
    let value = value_tmp.as_ref();
    PublicKeyMapEntry::create(_fbb, &PublicKeyMapEntryArgs{
      key,
      value,
    })
  }
}
